## Thunks

#### or, handling side-effects in an immutable system

In any typical application you are likely going to need to interact asynchronously
with external resources.

For example, a simple service to interact wih a remote API:

_*file: services/demo/UsersApi.ts*_

```typescript
import axios, { AxiosError, AxiosResponse } from 'axios';
import { IUser } from '../@interfaces/demo';

axios.defaults.baseURL = 'https://jsonplaceholder.typicode.com/';

export const fetchUsers = async (): Promise<Array<IUser>> => {
  try {
    const response: AxiosResponse = await axios.get('/users');

    return response.data;
  } catch (err: any) {
    if (err.response) {
      // utilize the more robust AxiosError
      const e = err as AxiosError;
      if (e.response!.authenticationStatus === 404 && !e.response!.data?.message) {
        e.response!.data = e.response!.data || {};
        e.response!.data.message = 'Invalid API endpoint';
      }
      throw e;
    }

    throw new Error(`UsersApi.fetchUsers error: ${err.message}`);
  }
};
```

This creates a problem as our reducers need to be pure functions, ie: no side effects allowed.
Attempting to dispatch an action from a reducer is highly frowned upon antipattern in the Redux
community, so the question arises as to how can we handle awaiting an asynchronous task to complete
prior to updating our state?

One of the primary solutions to this issue is a programming concept called a **thunk**. In its
simplest definition a thunk is merely a function that is returned from another function. The thunk
function generated by Redux Toolkit's `createAsyncThunk` handles initiating our
asynchronous process and dispatching actions to the store to inform it of the various states
of our request - ideally those states being **pending**, **fulfilled**, or **rejected** status. The toolkit
makes this process extremely simple:

_*file: /src/store/slices/user.ts*_

```typescript
import { createAsyncThunk } from '@reduxjs/toolkit';
import { fetchUsers } from '../../services/UsersApi';

/* ... */

export const loadUsers = createAsyncThunk(
  // the type prefix used when building the async authenticationStatus actions
  //  such as 'user/fetchUsers/pending' and 'user/fetchUsers/rejected' etc.
  'user/fetchUsers',
  async (arg: void, { rejectWithValue }) => {
    try {
      return await fetchUsers();
    } catch (e) {
      return rejectWithValue(
        e.response?.data?.message || e.message || 'Internal Server Error',
      );
    }
  },
);

/* ... */
```

The code generated by `createAsyncThunk` dispatches actions to keep us informed of the status of our
asynchronous request. We can strongly type this with a simple enumeration.

**NOTE:** _Idle_ is simply a placeholder for the pre-flight authenticationStatus of our thunk and could
be called anything we like. **Pending**, **Success**, and **Fail** are the actual states relayed by the
generated thunk.

_*file: /src/@enums/AsyncStates.ts*_

```typescript
enum AsyncStates {
  Idle = 'IDLE',
  Pending = 'PENDING',
  Success = 'SUCCESS',
  Fail = 'FAIL',
}

export default AsyncStates;
```

A custom type for our thunk's various async states:

_*file: /src/@types/AsyncStatus.ts*_

```typescript
import AsyncStates from '../@enums/AsyncStates';

type AsyncStatus =
  | AsyncStates.Idle
  | AsyncStates.Pending
  | AsyncStates.Success
  | AsyncStates.Fail;

export default AsyncStatus;
```

The actions created by `createAsyncThunk` differ from the actions generated for the standard reducer logic.
We define the reducers for the **pending**, **fulfilled**, and **rejected** states of an async action in
the slice's `extraReducers` factory method.

_*file: store/slices/user.ts*_

```typescript
/* ... */

const initialState: IUserSlice = {
  current: null,
  users: [],
  status: AsyncStates.Idle,
  error: null,
};

export const user = createSlice({
  name: 'user',
  initialState,
  reducers: {
    /* ... */
  },
  // because we are using TypeScript we need to use the "builder"
  // syntax for defining our extra reducers
  extraReducers: builder => {
    // typeprefix + status: 'users/fetchUsers/pending'
    //   maybe you need a spinner?
    builder.addCase(loadUsers.pending, (state: IUserSlice) => {
      state.status = AsyncStates.Pending;
    });

    // 'users/fetchUsers/fufilled'
    //   NOTE: this does not need to have a payload to add to state
    //         this could be the successful result any asynchronous action
    //         such as verifying that a record was added or updated on the
    //         server
    builder.addCase(
      loadUsers.fulfilled,
      (state: IUserSlice, action: PayloadAction<Array<IUser> | undefined>) => {
        state.status = AsyncStates.Success;
        state.users = [...state.users, ...(action.payload as Array<IUser>)];
      },
    );

    // 'users/fetchUsers/rejected'
    //   use this as an opportunity to clean up the state of this
    //   slice, and give feedback to the user
    builder.addCase(loadUsers.rejected, (state: IUserSlice, action) => {
      state.status = AsyncStates.Fail;
      state.error = action.payload as string;
      state.users = [];
    });
  },
});

/* ... */
```

### Final Slice

Note the addition of a pair of simple reducers for keeping track
of a current user out of the users array. If you have a fairly stable collection
of information, say a list of Counties or States, you very likely only need load them
once with little to no need to re-query individual items from the back-end as you already
have the necessary information housed in the full collection.

_*file: store/slices/user.ts*_

```typescript
import { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit';
import { IStore } from '../index';
import IUser from '../../@interfaces/IUser';
import { fetchUsers } from '../../services/UsersApi';
import AsyncStatus from '../../@types/AsyncStatus';
import AsyncStates from '../../@enums/AsyncStates';

export interface IUserSlice {
  current: IUser | null;
  users: Array<IUser>;
  status: AsyncStatus;
  error: string | null;
}

const initialState: IUserSlice = {
  current: null,
  users: [],
  status: AsyncStates.Idle,
  error: null,
};

export const loadUsers = createAsyncThunk(
  'users/fetchUsers',
  async (arg: void, { rejectWithValue }) => {
    try {
      return await fetchUsers();
    } catch (e) {
      return rejectWithValue(
        e.response?.data?.message || e.message || 'Internal Server Error',
      );
    }
  },
);

export const user = createSlice({
  name: 'user',
  initialState,
  reducers: {
    clearCurrentUser: (state: IUserSlice) => {
      state.current = null;
    },
    setCurrentUser: (state: IUserSlice, action: { type: string; payload: number }) => {
      const user = state.users.find(x => x.id === action.payload);

      if (user) {
        state.current = user;
        state.error = null;
      } else {
        state.current = null;
        state.error = 'user not found';
      }
    },
  },
  extraReducers: builder => {
    builder.addCase(loadUsers.pending, (state: IUserSlice) => {
      state.status = AsyncStates.Pending;
    });

    builder.addCase(
      loadUsers.fulfilled,
      (state: IUserSlice, action: PayloadAction<Array<IUser> | undefined>) => {
        state.status = AsyncStates.Success;
        state.users = [...state.users, ...(action.payload as Array<IUser>)];
      },
    );

    builder.addCase(loadUsers.rejected, (state: IUserSlice, action) => {
      state.status = AsyncStates.Fail;
      state.error = action.payload as string;
      state.users = [];
    });
  },
});

export const { setCurrentUser, clearCurrentUser } = user.actions;

export const selectCurrentUser = (state: IStore) => state.user.current;
export const selectUsers = (state: IStore) => state.user.users;

export default user.reducer;
```

## Use in a Functional Component

- single-fire useEffect pattern
- monitoring the async states with ad-hoc selector

_*file: /src/pages/Users/Users.tsx*_

```typescript jsx
import React, { FC, useEffect } from 'react';
import { useAppDispatch, useAppSelector } from '../../helpers';
import AsyncStates from '../../@enums/AsyncStates';
import IUser from '../../@interfaces/IUser';
import { loadUsers, selectUsers } from '../../store/slices/user';

const Users: FC = () => {
  const dispatch = useAppDispatch();
  const users = useAppSelector(selectUsers);
  // ad-hoc selectors
  const status = useAppSelector(state => state.user.status);
  const error = useAppSelector(state => state.user.error);

  useEffect(() => {
    // Let us suppose that fetching the users is an expensive operation
    // that we want to repeat as little as possible. By keeping the collection
    // in the global store we can reduce the number of queries we will need to
    // make to the back end to retrieve identical information.
    //
    // Should we unload, then later reload this component, the slice will likely
    // have a status of 'AsyncStates.Success' and the users array will contain
    // elements - therefore no "dispatch" to loadUsers will occur
    if (status === AsyncStates.Idle && !users.length) {
      dispatch(loadUsers());
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  return (
    <table className="table">
      <thead>
        <tr className="table-info">
          <th>Name</th>
          <th>City</th>
          <th>Zip</th>
          <th>Company</th>
        </tr>
      </thead>
      <tbody>
        {users.length ? (
          users.map((user: IUser) => (
            <tr key={user.id} data-testid={`row_${user.id}`}>
              <td>{user.name}</td>
              <td>{user.address?.city || 'unknown'}</td>
              <td>{user.address?.zipcode || 'unknown'}</td>
              <td>{user.company?.name || 'unknown'}</td>
            </tr>
          ))
        ) : status === AsyncStates.Fail ? (
          <tr>
            <td data-testid="error-indicator" colSpan={4}>
              Error: {error}
            </td>
          </tr>
        ) : (
          <tr>
            <td data-testid="loading-indicator" colSpan={4}>
              Loading...
            </td>
          </tr>
        )}
      </tbody>
    </table>
  );
};

export default Users;
```
