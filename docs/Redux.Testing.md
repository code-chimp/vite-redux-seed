# Redux Testing

## Slices

Here we are mainly concerned with testing **reducer** logic and any
asynchronous **thunk** logic. The **action creators** are simple object
factories that are generated by the toolkit so there is no need
to test them here - they will not affect line coverage. There
will be some verification of the actions at the component level tests.
Likewise there is no benefit in unit testing **selectors**.

### Testing Simple Reducer Logic:

_*file: /src/store/slices/counter.test.tsx*_

```typescript
import { counter, ICounterSlice } from './counter';

describe('store / slices / counter', () => {
  describe('reducers', () => {
    // only mock the initial state of the slice under test
    const initialState: ICounterSlice = { value: 15 };

    it('should increment the value', () => {
      // reference to the action creator we are testing
      const { increment } = counter.actions;
      const expected = 18;

      // reducers take two arguments:
      //   1. current state of the slice
      //   2. action being handled
      // and return a new state for the slice based on the
      // insructions in the reducer
      let state = counter.reducer(initialState, increment());
      state = counter.reducer(state, increment());
      state = counter.reducer(state, increment());

      expect(state.value).toBe(expected);
    });

    it('should decrement the value', () => {
      const { decrement } = counter.actions;
      const expected = 12;

      let state = counter.reducer(initialState, decrement());
      state = counter.reducer(state, decrement());
      state = counter.reducer(state, decrement());

      expect(state.value).toBe(expected);
    });
  });
});
```

### Testing Async Thunk Extra Reducers

_*file: /src/store/slices/user.test.ts*_

```typescript
import thunk from 'redux-thunk';
import configureMockStore, { MockStoreEnhanced } from 'redux-mock-store';
import { initialState, IUserSlice, loadUsers, user } from './user';
import { IUser } from '../../@interfaces/demo';

import * as usersApi from '../../services/demo/UsersApi';
jest.mock('../../services/demo/UsersApi');

describe('store / slices / user', () => {
  describe('reducer(s)', () => {
    it('should set the current user from the list of users', () => {
      const { setCurrentUser } = user.actions;
      const users: Array<IUser> = [
        { id: 1, name: 'A User' } as IUser,
        { id: 2, name: 'B User' } as IUser,
      ];

      let state: IUserSlice = {
        ...initialState,
        users: [...users],
      };

      state = user.reducer(state, setCurrentUser(1));

      expect(state.current).not.toBeNull();
      expect(state.current).toEqual(users[0]);
    });

    it('should clear the current user', () => {
      const { clearCurrentUser } = user.actions;

      let state: IUserSlice = {
        ...initialState,
        current: { id: 1, name: 'A User' } as IUser,
      };

      state = user.reducer(state, clearCurrentUser());

      expect(state.current).toBeNull();
    });
  });

  describe('thunk(s)', () => {
    // We will require an actual mock store to test asynchronous logic
    const mockStore = configureMockStore([thunk]);
    let store: MockStoreEnhanced<unknown, {}>;

    describe('loadUsers', () => {
      beforeEach(() => {
        store = mockStore(initialState);
      });

      it('should dispatch `pending` and `success` actions', async () => {
        const mockResponse: Array<Partial<IUser>> = [
          { id: 7, name: 'Pat User' },
          { id: 8, name: 'Joe User' },
        ];
        (usersApi.fetchUsers as jest.Mock).mockResolvedValueOnce(mockResponse);

        // unique identifiers are produced for actions generated by
        // `createAsyncThunk` - it is easiest to verify the action types
        // and the order they were fired in
        const expectedTypes = [loadUsers.pending.type, loadUsers.fulfilled.type];

        // @ts-ignore
        await store.dispatch(loadUsers());

        // this will give us the full array of actions processed
        // by the mock store in order
        const receivedActions = store.getActions();

        // we'll just grab the types to verify the order against what
        // we expected to happen
        const receivedTypes = receivedActions.map(action => action.type);
        // we can also peel the success action out so that we can verify
        //  its payload is what we expect
        const fulfilledAction = receivedActions.find(
          action => action.type === loadUsers.fulfilled.type,
        );

        expect(receivedTypes).toEqual(expectedTypes);
        expect(fulfilledAction).not.toBeNull();
        expect(fulfilledAction.payload).toEqual(mockResponse);
      });

      it('should dispatch `pending` and `fail` actions', async () => {
        const mockError = new Error('mock error');
        (usersApi.fetchUsers as jest.Mock).mockRejectedValueOnce(mockError);

        const expectedTypes = [loadUsers.pending.type, loadUsers.rejected.type];

        // @ts-ignore
        await store.dispatch(loadUsers());

        const receivedActions = store.getActions();
        const receivedTypes = receivedActions.map(action => action.type);
        const errorAction = receivedActions.find(
          action => action.type === loadUsers.rejected.type,
        );

        expect(receivedTypes).toEqual(expectedTypes);
        expect(errorAction.error.message).toBe('Rejected');
        expect(errorAction.payload).toBe(mockError.message);
      });
    });
  });
});
```

## Root Reducer (store/index.ts):

This is a very rudimentary operation of assembling the slice reducers
into a pipeline. There is really nothing of value to test in the root reducer.

## Components

Due to the inherent immutable nature of the central redux store, components
should merely be a reflection of the current state of the store with a secondary
function of dispatching actions to instruct the store on how to evolve the
application state.

Unit testing such a component involves determining if it dispatches the
correct actions and payloads based on intended state changes, and does
the rendered output correctly reflect every possible combination of the observed
state values that the component is concerned with. The smaller and more focused
we keep our components, the easier the unit testing will be.

_*file: /src/pages/Counter/Counter.test.tsx*_

```typescript jsx
import React from 'react';
import { Provider } from 'react-redux';
import configureMockStore, { MockStore } from 'redux-mock-store';
import { fireEvent, render } from '@testing-library/react';
import Counter from './Counter';
import { counter } from '../../store/slices/counter';

const mockStore = configureMockStore([]);
let store: MockStore;

function getComponent(initialState: number): () => DocumentFragment {
  store = mockStore({
    counter: { value: initialState },
  });

  const { asFragment } = render(
    <Provider store={store}>
      <Counter />
    </Provider>,
  );

  return asFragment;
}

describe('components / Counter', () => {
  it('should match the snapshot', () => {
    const asFragment = getComponent(0);

    expect(asFragment()).toMatchSnapshot();
  });

  // Testing: Does the component dispatch expected actions
  it('should dispatch an increment action when the add button is clicked', () => {
    getComponent(0);
    const expected = [counter.actions.increment.type];

    const addButton = screen.getByTestId('add-button');
    expect(addButton).toBeInTheDocument();

    fireEvent.click(addButton);

    const received = store.getActions().map(action => action.type);
    expect(received).toEqual(expected);
  });

  it('should dispatch a decrement action when the subtract button is clicked', () => {
    getComponent(0);
    const expected = [counter.actions.decrement.type];

    const subtractButton = screen.getByTestId('subtract-button');
    expect(subtractButton).toBeInTheDocument();

    fireEvent.click(subtractButton);

    const received = store.getActions().map(action => action.type);
    expect(received).toEqual(expected);
  });

  it('should accurately reflect observed state', () => {
    getComponent(15);
    const expected = '15';

    const outputDisplay = screen.getByTestId('output-display');
    expect(outputDisplay.textContent).toBe(expected);
  });
});
```

Note the addition of the **thunk** middleware to the mock store creator due to
our dispatching of the load action inside of the **useEffect** hook.

_*file: /src/pages/Users/Users.test.tsx*_

```typescript jsx
import React from 'react';
import { render, screen } from '@testing-library/react';
import { Provider } from 'react-redux';
import thunk from 'redux-thunk';
import configureMockStore, { MockStore } from 'redux-mock-store';
import Users from './Users';
import { AsyncStates } from '../../@enums';
import { initialState, loadUsers } from '../../store/slices/user';

const mockStore = configureMockStore([thunk]);
let store: MockStore;

describe('components / Users', () => {
  it('should match the snapshot', () => {
    store = mockStore({
      user: { ...initialState },
    });

    const { asFragment } = render(
      <Provider store={store}>
        <Users />
      </Provider>,
    );

    expect(asFragment()).toMatchSnapshot();
  });

  it('should render a spinner in the default state and dispatch the load action', () => {
    store = mockStore({
      user: { ...initialState },
    });

    render(
      <Provider store={store}>
        <Users />
      </Provider>,
    );

    const spinnerText = component.getByText('Loading...');
    expect(spinnerText).toBeInTheDocument();

    const actionsDispatched = store.getActions().map(action => action.type);
    expect(actionsDispatched).toEqual([loadUsers.pending.type]);
  });

  it('should render a spinner in the pending state and not dispatch the load action', () => {
    store = mockStore({
      user: { ...initialState, authenticationStatus: AsyncStates.Pending },
    });

    render(
      <Provider store={store}>
        <Users />
      </Provider>,
    );

    const spinnerText = screen.getByText('Loading...');
    expect(spinnerText).toBeInTheDocument();

    // does not satisfy the condition inside of the `useEffect`
    expect(store.getActions()).toEqual([]);
  });

  it('should render an error in the failed state', () => {
    store = mockStore({
      user: {
        ...initialState,
        status: AsyncStates.Fail,
        error: 'shabubu',
      },
    });

    render(
      <Provider store={store}>
        <Users />
      </Provider>,
    );

    const error = screen.getByTestId('error-indicator');
    expect(error).toBeInTheDocument();
    expect(error.textContent).toBe('Error: shabubu');

    // should not have satisfied the condition inside of the `useEffect`
    expect(store.getActions()).toEqual([]);
  });

  it('should render users upon success', () => {
    store = mockStore({
      user: {
        ...initialState,
        users: [
          {
            id: 1,
            name: 'A User',
            address: { city: 'Test', zipcode: 'test' },
            company: { name: 'Really Cool Co.' },
          },
          {
            id: 2,
            name: 'B User',
            address: { city: 'Test', zipcode: 'test' },
            company: { name: 'Really Cool Co.' },
          },
        ],
        status: AsyncStates.Success,
      },
    });

    render(
      <Provider store={store}>
        <Users />
      </Provider>,
    );

    const rows = screen.querySelectorAll('[data-row-key]');
    expect(rows).not.toBeNull();
    expect(rows.length).toBe(store.getState().user.users.length);

    // should not have satisfied the condition inside of the `useEffect`
    expect(store.getActions()).toEqual([]);
  });
});
```
